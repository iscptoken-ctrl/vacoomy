<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Vacoomy</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{--bg:#eee;--canvas-bg:#fff;--panel:#000}
  body{margin:0;height:100vh;display:flex;align-items:center;justify-content:center;background:var(--bg);font-family:Inter,system-ui,Arial;overflow:hidden}
  #gameCanvas{background:var(--canvas-bg);border:3px solid #222;display:none;touch-action:none}
  #hud{position:absolute;left:12px;top:10px;font-weight:700}
  #score{font-size:18px}
  #timer{position:absolute;right:12px;top:10px;font-weight:700;font-size:18px}
  #overlay{position:absolute;inset:0;background:rgba(0,0,0,0.75);color:#fff;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:12px}
  #overlay .box{background:rgba(255,255,255,0.06);padding:18px;border-radius:10px;text-align:center;min-width:260px}
  #overlay input{padding:10px;border-radius:6px;border:1px solid #444;width:220px}
  #overlay button{padding:10px 18px;border-radius:6px;border:none;background:#0b84ff;color:#fff;font-weight:700;cursor:pointer}
  #overlay small{opacity:.85;font-size:13px}
  #rankingPanel{position:absolute;left:12px;bottom:12px;background:rgba(0,0,0,0.7);color:#fff;padding:8px;border-radius:8px;font-size:13px;max-width:260px;max-height:220px;overflow:auto}
  #levelBadge{position:absolute;left:12px;top:42px;background:#222;color:#fff;padding:6px 8px;border-radius:8px;font-weight:700}
  @media (max-width:700px){
    #gameCanvas{width:92vw;height:92vw}
  }
</style>
</head>
<body>
  <div id="hud"><div id="score">Score: 0</div></div>
  <div id="timer">02:00</div>
  <canvas id="gameCanvas" width="600" height="600" tabindex="0"></canvas>

  <div id="overlay">
    <div class="box">
      <h2 style="margin:0 0 8px 0">Vacoomy</h2>
      <small style="display:block;margin-bottom:8px">Enter your name and press Start</small>
      <input id="nameInput" placeholder="Your name (max 16 chars)" maxlength="16" />
      <div style="height:10px"></div>
      <button id="startBtn" disabled>Start</button>
      <div style="height:8px"></div>
      <small id="notice" style="opacity:.85">Global ranking will be saved (username optional).</small>
    </div>
  </div>

  <div id="rankingPanel">Ranking: (loading...)</div>
  <div id="levelBadge">Level: 1</div>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
<script>
/* -----------------------------
   Supabase settings (your keys)
   ----------------------------- */
const SUPABASE_URL = `https://rwpzycqetqfeasveviho.supabase.co`;
const SUPABASE_KEY = `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJ3cHp5Y3FldHFmZWFzdmV2aWhvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjUxMzEwOTYsImV4cCI6MjA4MDcwNzA5Nn0.Rj0zvPhqgfJBIcp_RA6kmRj-vLpBumz-Tu0BNRQoKmI`;
let supabase = null;
try { supabase = supabaseJs.createClient(SUPABASE_URL, SUPABASE_KEY); }
catch(e){ console.warn("Supabase init failed:", e); supabase = null; }

/* -----------------------------
   DOM refs
   ----------------------------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const timerEl = document.getElementById('timer');
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('startBtn');
const nameInput = document.getElementById('nameInput');
const rankingPanel = document.getElementById('rankingPanel');
const levelBadge = document.getElementById('levelBadge');

/* -----------------------------
   Game state
   ----------------------------- */
let width = canvas.width = 600;
let height = canvas.height = 600;

let player = { x: width/2, y: height/2, size: 40, emoji: 'ðŸ¤–' };
let suckRadius = 60;      // dynamic suction radius, visible
let numbers = [];
let score = 0;
let totalTime = 120;      // seconds
let elapsedFrames = 0;
let gameRunning = false;
let spawnInterval = null;
let keys = {};
let touchTarget = null;
let level = 1;
let levelThreshold = 50;  // points per level
let name = '';

/* -----------------------------
   UI helpers
   ----------------------------- */
function formatTime(seconds){
  const m = Math.floor(seconds/60).toString().padStart(2,'0');
  const s = (seconds%60).toString().padStart(2,'0');
  return `${m}:${s}`;
}
function updateHUD(){ scoreEl.textContent = `Score: ${score}`; levelBadge.textContent = `Level: ${level}`; }

/* -----------------------------
   Spawn numbers (more frequent)
   ----------------------------- */
function spawnNumbers(){
  if(!gameRunning) return;
  for(let i=0;i<3;i++){
    const val = Math.floor(Math.random()*9)+1;
    numbers.push({
      x: Math.random()*(width-30)+15,
      y: Math.random()*(height-30)+15,
      v: val,
      ttl: val * 60
    });
  }
}

/* -----------------------------
   Draw
   ----------------------------- */
function drawPlayer(){
  // suction area: filled + stroke so visible
  ctx.fillStyle = 'rgba(0,120,255,0.12)';
  ctx.beginPath();
  ctx.arc(player.x, player.y, suckRadius, 0, Math.PI*2);
  ctx.fill();
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(0,120,255,0.6)';
  ctx.beginPath();
  ctx.arc(player.x, player.y, suckRadius, 0, Math.PI*2);
  ctx.stroke();

  // robot emoji
  ctx.font = `${player.size}px serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = '#222';
  ctx.fillText(player.emoji, player.x, player.y);
}

function drawNumbers(){
  ctx.font = '20px Arial';
  ctx.fillStyle = 'red';
  for(const n of numbers){
    ctx.fillText(n.v, n.x, n.y);
  }
}

/* -----------------------------
   Movement and physics
   ----------------------------- */
function update(){
  if(!gameRunning) return;

  // keyboard WASD
  if(keys.w) player.y -= 5;
  if(keys.s) player.y += 5;
  if(keys.a) player.x -= 5;
  if(keys.d) player.x += 5;

  // mobile target
  if(touchTarget){
    const dx = touchTarget.x - player.x;
    const dy = touchTarget.y - player.y;
    player.x += dx * 0.06;
    player.y += dy * 0.06;
  }

  // clamp
  player.x = Math.max(0, Math.min(width, player.x));
  player.y = Math.max(0, Math.min(height, player.y));

  // attraction and collection
  for(let i=numbers.length-1;i>=0;i--){
    const n = numbers[i];
    const dx = player.x - n.x;
    const dy = player.y - n.y;
    const dist = Math.hypot(dx,dy);

    if(dist < suckRadius){
      // attraction strength scales with level (larger level -> faster)
      const strength = 0.03 + (level-1)*0.01;
      n.x += dx * strength;
      n.y += dy * strength;
    }

    if(dist < Math.max(14, player.size*0.5)){ // collect
      score += n.v;
      numbers.splice(i,1);
      // possibly level up
      const newLevel = Math.floor(score / levelThreshold) + 1;
      if(newLevel > level){
        level = newLevel;
        suckRadius += 10; // increase suction radius per level
      }
      updateHUD();
    }

    // ttl decrement
    n.ttl--;
    if(n.ttl <= 0) numbers.splice(i,1);
  }

  // timer
  elapsedFrames++;
  const remaining = Math.max(0, totalTime - Math.floor(elapsedFrames / 60));
  timerEl.textContent = formatTime(remaining);

  if(remaining <= 0){
    endGame();
  }
}

/* -----------------------------
   Game loop
   ----------------------------- */
function loop(){
  ctx.clearRect(0,0,width,height);
  update();
  drawNumbers();
  drawPlayer();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* -----------------------------
   Start / Reset / End
   ----------------------------- */
function resetGame(){
  player.x = width/2; player.y = height/2;
  suckRadius = 60;
  numbers = [];
  score = 0;
  elapsedFrames = 0;
  level = 1;
  levelBadge.textContent = `Level: ${level}`;
  updateHUD();
  timerEl.textContent = formatTime(totalTime);
}

function startGame(){
  resetGame();
  gameRunning = true;
  spawnNumbers(); // immediate
  spawnInterval = setInterval(spawnNumbers, 500);
}

function endGame(){
  gameRunning = false;
  if(spawnInterval) clearInterval(spawnInterval);
  // try to save to supabase: attempt with username if present, otherwise fallback to score only
  (async ()=>{
    try {
      if(supabase){
        if(name){
          // try insert with username
          const { error } = await supabase.from('scores').insert([{ score: score, username: name }]);
          if(error){
            console.warn("Insert with username failed, trying without username:", error);
            await supabase.from('scores').insert([{ score }]);
          }
        } else {
          await supabase.from('scores').insert([{ score }]);
        }
      }
    } catch(e){
      console.warn("Supabase save error:", e);
    }
    // show overlay and ranking
    document.getElementById('message').textContent = `Game Over! Score: ${score}`;
    startBtn.textContent = "Play Again";
    overlay.style.display = 'flex';
    try { await fetchAndRenderRanking(); } catch(e){ console.warn(e); }
  })();
}

/* -----------------------------
   Ranking: fetch & render
   ----------------------------- */
async function fetchAndRenderRanking(){
  rankingPanel.textContent = "Ranking: loading...";
  // first try to select username+score
  if(!supabase){
    rankingPanel.textContent = "Ranking: not available (no backend)";
    return;
  }
  try {
    // attempt selecting username
    let { data, error } = await supabase
      .from('scores')
      .select('score, username')
      .order('score', { ascending: false })
      .limit(10);

    if(error || !Array.isArray(data) || data.length===0){
      // fallback: try selecting only score
      const { data: data2, error: err2 } = await supabase
        .from('scores')
        .select('score')
        .order('score', { ascending: false })
        .limit(10);
      if(err2){
        rankingPanel.textContent = "Ranking: not available (backend error)";
        console.warn(err2);
        return;
      }
      // render score-only
      rankingPanel.innerHTML = "<b>Global Ranking</b><br>" + data2.map((r,i)=>`${i+1}. ${r.score}`).join('<br>');
      return;
    }

    // render username+score (username might be null)
    rankingPanel.innerHTML = "<b>Global Ranking</b><br>" + data.map((r,i)=> {
      const user = r.username ? `${r.username}` : 'â€”';
      return `${i+1}. ${user} â€” ${r.score}`;
    }).join('<br>');

  } catch(e){
    console.warn(e);
    rankingPanel.textContent = "Ranking: error fetching";
  }
}

/* -----------------------------
   Supabase helper used on end as well
   ----------------------------- */
async function tryShowRankingOnLoad(){
  try { await fetchAndRenderRanking(); } catch(e){ console.warn(e); }
}
tryShowRankingOnLoad();

/* -----------------------------
   Input and controls
   ----------------------------- */
nameInput.addEventListener('input', () => {
  const v = nameInput.value.trim();
  startBtn.disabled = (v.length === 0);
});

startBtn.addEventListener('click', ()=>{
  const entered = nameInput.value.trim();
  name = entered.length ? entered : '';
  overlay.style.display = 'none';
  canvas.style.display = 'block';
  canvas.focus();
  startGame();
});

/* keyboard global */
document.addEventListener('keydown', e => {
  const k = e.key.toLowerCase();
  if(k==='w' || k==='a' || k==='s' || k==='d') keys[k] = true;
});
document.addEventListener('keyup', e => {
  const k = e.key.toLowerCase();
  if(k==='w' || k==='a' || k==='s' || k==='d') keys[k] = false;
});

/* mobile touch */
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  touchTarget = { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
});
canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  touchTarget = { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
});
canvas.addEventListener('touchend', e => {
  touchTarget = null;
});

/* resize handling: keep canvas square on small screens */
function resizeIfNeeded(){
  const vw = Math.min(window.innerWidth*0.92, 600);
  canvas.style.width = vw + 'px';
  canvas.style.height = vw + 'px';
}
window.addEventListener('resize', resizeIfNeeded);
resizeIfNeeded();

</script>
</body>
</html>
