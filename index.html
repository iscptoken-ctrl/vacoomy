<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Vacoomy â€” Robot Vacuum Game</title>
<style>
  :root{
    --bg:#f2f4f7;
    --panel:#ffffff;
    --accent:#0077ff;
  }
  html,body{height:100%;margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);display:flex;align-items:center;justify-content:center}
  #app{width:100%;max-width:900px;height:100vh;display:flex;align-items:center;justify-content:center;position:relative}
  #gameArea{position:relative;width:720px;height:720px;display:flex;align-items:center;justify-content:center}
  #gameCanvas{background:var(--panel);border:2px solid #ccc;border-radius:8px;touch-action:none;display:block}
  #hud { position:absolute; top:10px; left:10px; right:10px; display:flex; justify-content:space-between; pointer-events:none; }
  .hud-left, .hud-right{pointer-events:auto; display:flex; gap:12px; align-items:center; }
  .badge{background:#fff;padding:8px 12px;border-radius:8px;box-shadow:0 1px 3px rgba(0,0,0,0.08);font-weight:600}
  #overlay{position:absolute;inset:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:50}
  #panel{background:var(--panel);color:#111;padding:24px;border-radius:12px;min-width:320px;box-shadow:0 10px 30px rgba(0,0,0,0.2);text-align:center}
  #panel h1{margin:0 0 12px;font-size:22px}
  #panel p{margin:8px 0 18px;color:#444}
  #nameInput{width:100%;padding:10px;border-radius:8px;border:1px solid #ddd;font-size:16px}
  #startBtn{background:var(--accent);color:#fff;border:none;padding:10px 16px;border-radius:8px;font-weight:700;cursor:pointer;margin-top:12px}
  #startBtn:disabled{opacity:0.5;cursor:not-allowed}
  #rankingBox{margin-top:12px;text-align:left;max-height:180px;overflow:auto}
  #rankingBox ol{margin:6px 0 0;padding-left:18px}
  #smallNote{font-size:12px;color:#666;margin-top:8px}
  #levelBadge{min-width:60px;text-align:center}
  @media(max-width:900px){ #gameArea{width:95vw;height:95vw} #panel{min-width:260px} }
</style>
</head>
<body>
<div id="app">
  <div id="gameArea">
    <canvas id="gameCanvas" width="600" height="600" tabindex="0"></canvas>

    <div id="hud">
      <div class="hud-left">
        <div id="scoreBadge" class="badge">Score: 0</div>
        <div id="levelBadge" class="badge">Level: 1</div>
      </div>
      <div class="hud-right">
        <div id="timerBadge" class="badge">02:00</div>
        <div id="rankBtn" class="badge" style="cursor:pointer">Global Ranking</div>
      </div>
    </div>

    <div id="overlay">
      <div id="panel">
        <h1>Vacoomy</h1>
        <p>Enter your username to start. Use <strong>WASD</strong> on PC or touch to move on mobile.</p>
        <input id="nameInput" placeholder="Username (max 16 chars)" maxlength="16" />
        <button id="startBtn" disabled>Start</button>

        <div id="smallNote">Global ranking available if backend connected.</div>

        <div id="rankingBox" style="display:none">
          <h3>Top Players</h3>
          <ol id="rankingList"></ol>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Supabase CDN -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
<script>
/* -------------------------
   CONFIG - change here if needed
   ------------------------- */
// Use your Supabase info (or keep the values provided earlier).
const SUPABASE_URL = `https://rwpzycqetqfeasveviho.supabase.co`;
const SUPABASE_KEY = `sb_publishable_Bx5RBH5HrKmz8p8YRRH--Q_s-AYrwvt`; // if you have anon/public anon key, prefer that; publishable also works for read in some configs
/* ------------------------- */

let supabase = null;
try {
  supabase = supabaseJs.createClient(SUPABASE_URL, SUPABASE_KEY);
} catch(e){
  console.warn("Supabase init failed:", e);
  supabase = null;
}

/* --------- Game state ---------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const startBtn = document.getElementById('startBtn');
const nameInput = document.getElementById('nameInput');
const overlay = document.getElementById('overlay');
const scoreBadge = document.getElementById('scoreBadge');
const timerBadge = document.getElementById('timerBadge');
const levelBadge = document.getElementById('levelBadge');
const rankBtn = document.getElementById('rankBtn');
const rankingBox = document.getElementById('rankingBox');
const rankingList = document.getElementById('rankingList');

canvas.setAttribute('tabindex','0');

let width = canvas.width, height = canvas.height;
let vacuum = { x: width/2, y: height/2, size: 44, emoji: "ðŸ¤–", radius: 70 };
let numbers = [];
let score = 0;
let level = 1;
let levelThreshold = 50; // points to next level (simple)
let totalTime = 120; // seconds
let remainingSec = totalTime;
let gameRunning = false;
let spawnInterval = null;
let keys = {};
let targetX = null, targetY = null;

/* ---------- UI logic ---------- */
nameInput.addEventListener('input', ()=> {
  const val = nameInput.value.trim();
  startBtn.disabled = val.length === 0;
});
startBtn.addEventListener('click', ()=>{
  if(nameInput.value.trim().length === 0) return;
  overlay.style.display = 'none';
  resetGame();
  startGame();
});

/* show ranking button */
rankBtn.addEventListener('click', async ()=>{
  await fetchAndShowRanking();
});

/* ---------- input handlers ---------- */
document.addEventListener('keydown', e=>{
  const k = e.key.toLowerCase();
  if(["w","a","s","d"].includes(k)) keys[k] = true;
});
document.addEventListener('keyup', e=>{
  const k = e.key.toLowerCase();
  if(["w","a","s","d"].includes(k)) keys[k] = false;
});
canvas.addEventListener('touchstart', e=>{
  const rect = canvas.getBoundingClientRect();
  targetX = e.touches[0].clientX - rect.left;
  targetY = e.touches[0].clientY - rect.top;
}, {passive:true});
canvas.addEventListener('touchmove', e=>{
  const rect = canvas.getBoundingClientRect();
  targetX = e.touches[0].clientX - rect.left;
  targetY = e.touches[0].clientY - rect.top;
}, {passive:true});
canvas.addEventListener('mousedown', e=>{
  const rect = canvas.getBoundingClientRect();
  targetX = e.clientX - rect.left;
  targetY = e.clientY - rect.top;
});
canvas.addEventListener('mousemove', e=>{
  // optional: move target when mouse pressed? we only set on mousedown to avoid chasing mouse
});

/* ---------- spawn ---------- */
function spawnNumbers(batch=3){
  if(!gameRunning) return;
  for(let i=0;i<batch;i++){
    const value = Math.floor(Math.random()*9)+1;
    numbers.push({
      x: Math.random()*(width-40)+20,
      y: Math.random()*(height-40)+20,
      value,
      ttl: value * 90 // frames-ish
    });
  }
}

/* ---------- drawing ---------- */
function drawVacuum(){
  // suction area: filled semi-transparent + stroke
  ctx.beginPath();
  ctx.fillStyle = 'rgba(0,125,255,0.12)'; // light fill
  ctx.arc(vacuum.x, vacuum.y, vacuum.radius, 0, Math.PI*2);
  ctx.fill();
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(0,125,255,0.35)';
  ctx.beginPath();
  ctx.arc(vacuum.x, vacuum.y, vacuum.radius, 0, Math.PI*2);
  ctx.stroke();

  // robot emoji
  ctx.font = `${vacuum.size}px serif`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillStyle = "#0055aa";
  ctx.fillText(vacuum.emoji, vacuum.x, vacuum.y);
}

function drawNumbers(){
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.font = '20px Arial';
  for(let i=numbers.length-1;i>=0;i--){
    const num = numbers[i];
    ctx.fillStyle = '#ff3b3b';
    ctx.fillText(num.value, num.x, num.y);
    num.ttl--;
    if(num.ttl <= 0) numbers.splice(i,1);
  }
}

/* ---------- update ---------- */
function update(){
  if(!gameRunning) return;

  // keyboard movement
  if(keys["w"]) vacuum.y -= 4;
  if(keys["s"]) vacuum.y += 4;
  if(keys["a"]) vacuum.x -= 4;
  if(keys["d"]) vacuum.x += 4;

  // mobile target smoothing
  if(targetX !== null && targetY !== null){
    const dx = targetX - vacuum.x;
    const dy = targetY - vacuum.y;
    vacuum.x += dx * 0.08;
    vacuum.y += dy * 0.08;
  }

  // bounds
  vacuum.x = Math.max(10, Math.min(width-10, vacuum.x));
  vacuum.y = Math.max(10, Math.min(height-10, vacuum.y));

  // suction pull
  for(let i=numbers.length-1;i>=0;i--){
    const n = numbers[i];
    const dx = vacuum.x - n.x;
    const dy = vacuum.y - n.y;
    const dist = Math.hypot(dx,dy);

    if(dist < vacuum.radius){
      // pull speed depends on value and level (bigger value = slightly slower)
      const pull = 0.06 + (level-1)*0.01 + (n.value * 0.003);
      n.x += dx * pull;
      n.y += dy * pull;
    }

    // collect
    if(dist < Math.max(20, vacuum.size/2)){
      score += n.value;
      numbers.splice(i,1);
      checkLevelUp();
    }
  }

  // decrement timer per second using tick logic
}

/* ---------- level up ---------- */
function checkLevelUp(){
  const newLevel = Math.floor(score / levelThreshold) + 1;
  if(newLevel > level){
    level = newLevel;
    // increase suction radius but cap it
    vacuum.radius = Math.min(200, 70 + (level-1) * 15);
    levelBadge.textContent = `Level: ${level}`;
    // visual feedback (flash)
    flashVacuum();
  }
}

function flashVacuum(){
  // tiny effect: increase size momentarily
  const orig = vacuum.size;
  vacuum.size = orig + 8;
  setTimeout(()=> vacuum.size = orig, 220);
}

/* ---------- timer ---------- */
let lastTick = performance.now();
function tickTimer(now){
  if(!gameRunning) return;
  const delta = now - lastTick;
  if(delta >= 1000){
    remainingSec = Math.max(0, remainingSec - Math.floor(delta/1000));
    lastTick = now;
    const mm = String(Math.floor(remainingSec/60)).padStart(2,'0');
    const ss = String(remainingSec%60).padStart(2,'0');
    timerBadge.textContent = `${mm}:${ss}`;
    if(remainingSec <= 0){
      endGame();
    }
  }
}

/* ---------- game control ---------- */
function resetGame(){
  numbers = [];
  score = 0;
  level = 1;
  levelBadge.textContent = `Level: ${level}`;
  vacuum.x = width/2; vacuum.y = height/2;
  vacuum.radius = 70;
  remainingSec = totalTime;
  scoreBadge.textContent = `Score: ${score}`;
  timerBadge.textContent = `02:00`;
  lastTick = performance.now();
}

function startGame(){
  gameRunning = true;
  // focus canvas for keyboard
  try { canvas.focus(); } catch(e){}
  spawnNumbers(); // immediate
  spawnInterval = setInterval(()=> spawnNumbers(3), 500); // frequent
  lastTick = performance.now();
}

function endGame(){
  gameRunning = false;
  if(spawnInterval) { clearInterval(spawnInterval); spawnInterval = null; }
  // save to supabase if possible (non-blocking)
  (async ()=>{
    try {
      if(supabase){
        const username = (nameInput.value || "player").trim().slice(0,32);
        await supabase.from('scores').insert([{ username, score }]);
      } else {
        console.warn("Supabase not initialized; skipping save.");
      }
    } catch(err){
      console.warn("Failed saving score:", err);
    } finally {
      // show overlay with result and ranking
      showEndOverlay();
    }
  })();
}

function showEndOverlay(){
  overlay.style.display = 'flex';
  document.getElementById('panel').scrollIntoView({behavior:'smooth', block:'center'});
  // update panel text
  const panel = document.getElementById('panel');
  const msg = panel.querySelector('h1');
  msg.textContent = "Game Over";
  const p = panel.querySelector('p');
  p.textContent = `Your score: ${score}`;
  startBtn.textContent = "Play Again";
  // show ranking by fetching
  fetchAndShowRanking();
}

/* ---------- ranking ---------- */
async function fetchAndShowRanking(){
  rankingBox.style.display = 'block';
  rankingList.innerHTML = '<li>Loading...</li>';
  if(!supabase){
    rankingList.innerHTML = '<li>Global ranking unavailable (no backend)</li>';
    return;
  }
  try {
    const { data, error } = await supabase
      .from('scores')
      .select('username, score')
      .order('score', { ascending: false })
      .limit(10);
    if(error){ throw error; }
    if(!data || data.length === 0){
      rankingList.innerHTML = '<li>No scores yet</li>';
      return;
    }
    rankingList.innerHTML = data.map(r => `<li>${escapeHtml(r.username)} â€” ${r.score}</li>`).join('');
  } catch(err){
    console.error("Ranking fetch error:", err);
    rankingList.innerHTML = '<li>Failed to load ranking</li>';
  }
}

/* ---------- helpers ---------- */
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* ---------- main loop ---------- */
function loop(now){
  ctx.clearRect(0,0,width,height);
  update();
  drawVacuum();
  drawNumbers();

  // update score display
  scoreBadge.textContent = `Score: ${score}`;

  tickTimer(now || performance.now());
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ---------- window resize handling ---------- */
window.addEventListener('resize', ()=>{
  // keep canvas size fixed but adapt for small screens
  const box = canvas.getBoundingClientRect();
  width = canvas.width;
  height = canvas.height;
});

/* ---------- simple startup ranking display (non-blocking) ---------- */
(async ()=> {
  // If supabase present, preload ranking to show on overlay
  try {
    if(supabase) await fetchAndShowRanking();
  } catch(e){}
})();

</script>
</body>
</html>
